---
title: "정보의 저장"
date: "2025-09-17"
description: "C언어에서의 데이터 저장, 바이트 순서(Endian), 부울 대수, 비트/논리/쉬프트 연산 정리"
tags: ["CSAPP", "Bitwise", "C Language", "Jungle"]
---

메모리에 저장된 각각의 비트들을 접근하는 방식 대신에 대부분의 컴퓨터들은 메모리에서 주소지정이 가능한 최소단위인 **"8비트 단위의 블록인 바이트"**를 사용한다.

이유는 **1 비트당 주소를 할당하는게 효율적이지 않고, 명령어 구조가 복잡해지기 때문**이다.



### 16진수 표시
이진수 표시는 너무 장황하고, 십진수 표시는 비트 패턴을 표시하는데 매우 불편하다.
그 대신, **비트패턴을 16진수로 표현**한다고 한다.

그러니까 이 말은:
*   이진수 `0000` 이 16진수로 `0`
*   이진수 `0011`은 16진수로 `3`
*   이렇게 간단히 표기할 수 있다는 점

**1 바이트가 항상 16진수 2자리로 표현이 가능해 비트/바이트와 딱 맞아 떨어진다는 점**
사람이 읽고 쓰기 쉽기 때문에 16진수를 사용한다.



---

### 데이터의 크기
모든 컴퓨터는 **워드와 크기**를 규격으로 가지게 되는데, 이것은 **포인터의 정규 크기**를 표시한다.
여기서 워드크기는 CPU가 한 번에 처리할 수 있는 데이터의 **“표준 크기”**, 우리가 흔히 말하는 윈도우 32bit/64bit 할 때 그 비트의 수가 워드크기이다.

*   **32비트** 시스템의 워드 크기 -> `4바이트`
*   **64비트** 시스템의 워드 크기 -> `8바이트`

포인터는 메모리 주소를 저장하는 변수인데 그 크기는 위에 워드와 동일하다.
*   **32비트** 시스템의 포인터 크기 -> `4바이트`
*   **64비트** 시스템의 포인터 크기 -> `8바이트`

주소 공간의 범위가:
*   32비트 워드는 `2³²` = 약 **4GB** 까지만 주소화가 가능하고
*   64비트 워드는 `2⁶⁴` = 사실상 **무한대 수준** (수 페타바이트) 으로 가능하다.



---

### 주소지정과 바이트 순서 (Endian)
멀티바이트 데이터(예: int 4바이트 등)를 메모리에 저장하는 순서 방식을 말한다.
바이트 단위로 주소가 매겨지기 때문에, 같은 값이라도 어떤 순서로 놓느냐에 따라 다르게 보일 수 있다.

*   **리틀 엔디안 (Little Endian)**
    *   가장 작은 바이트(LSB, Least Significant Byte)를 **낮은주소(뒤쪽)**에 저장.
    *   뒤집어서 저장하는 방식이다. **(x86 / 인텔)**

*   **빅 엔디안 (Big Endian)**
    *   가장 큰 바이트(MSB, Most Significant Byte)를 **낮은주소(뒤쪽)**에 저장.
    *   사람이 읽는 순서(왼 -> 오)랑 같고, **네트워크에서 표준**으로 쓰인다. **(Sun / IBM)**



---

### 부울 Boolean 대수
쉽게 말해서 `0 = False` / `1 = True` 라고 보면 된다.

기본 부울 대수 연산으로는 **`and(&)` / `or(|)` / `not(~)` / `exclusive-or(^)`** 이거만 알면 될거 같다.

```c
0110 & 1100 = 0100
0110 | 1100 = 1110
0110 ^ 1100 = 1010
~ 1100 = 0011
```
> * 반전은 타입의 전체 비트폭에 적용됨 (예: 32비트 `~0x0000000C` = `0xFFFFFFF3`)



---

### C에서의 비트수준 연산
C는 정수타입 (`char`, `int`, `long` 등) 에대해 비트를 다루는 연산자를 제공한다.
(float와 double은 실수라서 비트연산 불가능)

*   **AND (`&`)** - 대응되는 두 비트가 모두 1 이면 1, 아니면 0
    *   `1101 & 1011 = 1001`
*   **OR (`|`)** - 대응되는 두 비트 중 하나라도 1이면 1
    *   `1101 | 1011 = 1111`
*   **XOR (`^`)** - 대응되는 두 비트가 서로 다르면 1, 같으면 0
    *   `1101 ^ 1011 = 0110`
*   **NOT (`~`)** - 각 비트를 반전 (0 > 1, 1 > 0)
    *   `~1101 = 0010`



---

### C에서의 논리 연산
C에서는 논리 연산의 OR, AND, NOT에 해당하는 논리연산자 **`||`, `&&`, `!`** 을 제공한다.
**비트수준의 연산과 혼동될 수 있지만, 동작은 전혀 다르니 헷갈리지 말도록 하자.**

논리 연산은 0은 거짓, 0이 아닌 것들은 참으로 취급하고, 결과가 참인지 거짓인지 **1 또는 0으로 리턴**한다.

```c
!0x41 = 0x00 // (!True 니까 False)
!0x00 = 0x01 // (!False 니까 True)
!!0x41 = 0x01 // (!!True 니까 True)

0x69 && 0x55 = 0x01 // (True && True == True) -> 하나라도 False면 False
0x69 || 0x55 = 0x01 // (True || True = True) -> 하나라도 True면 True
```



---

### C에서의 쉬프트 연산
쉽게 말해서 **비트 패턴을 좌우로 이동시키는 연산**이다.

#### `<<` (Left Shift)
비트를 왼쪽으로 이동시키고, 오른쪽은 0으로 채운다.
```c
int x = 3; // (0000 0011)
int y = x << 1; // 6 (0000 0110) -> 두배가 된다.
// 그러니까 y << 1 은 12 (0000 1100)가 된다는 걸 예상해볼 수 있다.
```

#### `>>` (Right Shift)
비트를 오른쪽으로 이동시키고, 왼쪽의 빈자리를 채우는 건 **논리 시프트(Logical shift)**냐 **산술 시프트(Arithmetic shift)**냐 에 따라 달라진다.
*   `<<` 를 써서 이동할 땐 두배였으니, 반대로 **나누기 2**를 하면 되겠다!

*   **논리 시프트** - 항상 0 으로 채움 (`unsigned`에서 보장)
*   **산술 시프트** - 부호 비트(MSB)를 복사 (`signed`에서 일반적으로 사용)

```c
unsigned int a = 14;   // 0000 1110
unsigned int b = a >> 1; // 0000 0111 → 7

// 앞이 1이면 -, 0이면 +라고 쉽게 생각하면 될 거 같다.
int c = -8;  // 1111 1000 (2의 보수, 8비트 가정)
int d = c >> 1;  // 산술 시프트라면 → 1111 1100 (-4)
```

**시프트 연산에서 주의할 점**
범위가 넘어가는 시프트는 정의 되지 않을 수 있다.
예를 들어서 32비트 `int`에서 `x << 32` 는 결과가 보장이 안된다.

그리고 시프트연산자의 우선순위는 덧셈, 곱셈 보다 낮으므로 **괄호를 써주는게 안전하다.**
```c
int y = 1 << 3 + 2;   // (3+2)=5 가 아니고, (1<<3)+2=10
int z = 1 << (3 + 2); // 1<<5 = 32
```



**PS. 책에 있는 연습문제들 좀 풀어보고, 익숙해지는게 좋을 거 같다**
