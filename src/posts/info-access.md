---
title: "정보 접근 (Accessing Information)"
date: "2025-09-26"
description: "X86-64 아키텍처의 레지스터, 오퍼랜드, 데이터 이동, 확장 규칙, 스택 동작 방식 정리"
tags: ["CSAPP", "Assembly", "X86-64", "Jungle"]
---

X86-64 CPU에는 **64비트 값을 저장할 수 있는 16개의 레지스터**가 있다.
이 레지스터는 정수 데이터뿐만 아니라 **포인터 (메모리주소) 도 저장**할 수 있다.



### 1. 역사
*   **8086 시대 (16비트)**
    *   `%ax`, `%bx`, `%cx`, `%dx`, `%si`, `%di`, `%bp`, `%sp` → 총 8개
    *   각각 특정 용도가 있다. (예: `%ax` = accumulator, `%sp` = stack pointer)
*   **IA32 (32비트 확장)**
    *   위에 8개의 레지스터가 32비트로 확장됨
    *   `%eax`, `%ebx`, `%ecx`, `%edx`, `%esi`, `%edi`, `%ebp`, `%esp`
*   **X86-64 (64비트 확장)**
    *   기존 8개의 레지스터를 64비트로 확장 (`%rax` … `%rsp`)
    *   **새로운 8개 레지스터 추가 (`%r8` ~ `%r15`)**



### 2. 값이 덮이는 규칙
*   **1바이트(b), 2바이트(w) 연산** → 나머지 상위 바이트는 그래로 유지
*   **4바이트(l) 연산** → 상위 4바이트는 **자동으로 0으로 채움**
*   **8바이트(q) 연산** → 전제 8바이트를 모두 덮어씀



### 3. 레지스터의 용도
*   `%rax`: **함수 반환값 저장**
*   `%rsp`: **스택 포인터 (stack pointer)**
*   `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`: **함수 인자(argument) 전달용 (1 ~ 6번째 인자)**
*   나머지 레지스터는 저장용도로 구분되어 사용 규칙이 정해져 있음

#### 예시
```assembly
movl $5, %eax
# %eax는 %rax의 하위 32비트 부분
# 그래서 %rax = 0000 0000 0000 0005 가 된다. (상위는 0으로 채움)

movb $0xFF, %al
# %al은 %rax의 하위 8비트 부분
# 따라서 %rax의 나머지 56비트는 그대로 두고, 하위 8비트만 FF로 바뀐다.
```



---

### 3.4.1 오퍼랜드 식별자 (Operand Specifier)
#### 1. 개념
*   **정의**: 명령어가 사용할 데이터가 어디에 있는지 알려주는 규칙이다.
*   명령어 하나에는 보통 **소스(Source)**와 **목적지(Destination)** 피연산자가 필요하다.
*   x86-64에서는 피연산자를 크게 **즉시 값, 레지스터, 메모리 참조**로 나눈다.

#### 2. 예시
*   **즉시 값 (immediate)**
    *   형태: `$Imm`
    *   설명: 명령어 안에 직접 들어있는 상수 값
    *   예: `$0x1F` → 그냥 16진수 1F라는 값 자체
*   **레지스터 (register)**
    *   형태: `ra` (예: `%rax`)
    *   설명: CPU 내부의 레지스터 값을 사용
    *   예: `%rdx` → rdx 레지스터에 들어있는 값
*   **메모리 참조 (memory)**
    *   메모리는 주소 계산을 여러 방식으로 할 수 있어서 더 복잡
    *   메모리는 항상 `M[주소]` 라는 형식으로 생각

**주소 지정 방식 (Addressing Mode)**
*   `Imm`: 절대주소 참조 (예: `0x104`)
*   `(ra)`: `R[ra]`에 있는 주소 참조 (예: `(%rax)`)
*   `Imm(rb)`: `Imm + R[rb]` (예: `4(%rbx)`)
*   `(rb, ri)`: `R[rb] + R[ri]` (예: `(%rbx, %rsi)`)
*   `Imm(rb, ri, s)`: `Imm + R[rb] + (R[ri] * s)` (가장 일반적인 형태)
    *   여기서 `s(scale factor)`는 반드시 **1, 2, 4, 8** 중 하나



---

### 3.4.2 데이터 이동 인스트럭션 (Data Movement Instructions)

#### 1. 개념
*   **정의**: 어떤 위치에 있는 데이터를 다른 위치로 복사하는 명령어 (계산X, 이동O)
*   **mov 계열**: `movb`, `movw`, `movl`, `movq`
    *   b = 1바이트 (byte)
    *   w = 2바이트 (word)
    *   l = 4바이트 (double word)
    *   q = 8바이트 (quad word)
*   **제약조건**: 소스와 목적지가 **동시에 메모리일 수 없음**. (메모리 → 레지스터 → 메모리 순서로 2단계를 거쳐야함)

#### 2. 예시
```assembly
# Immediate → Register
movl $0x4050, %eax   # 4바이트 상수값 → 레지스터

# Register → Register
movw %bp, %sp        # 2바이트 레지스터 → 레지스터

# Memory → Register
movb (%rdi, %rcx), %al   # 메모리(주소계산) → 레지스터

# Immediate → Memory
movb $-17, (%esp)    # 상수값 → 메모리

# Register → Memory
movq %rax, -12(%rbp) # 8바이트 레지스터 → 메모리
```
*   **특별한 경우 (`movabsq`)**: 64비트 상수를 그대로 레지스터에 복사할 때 사용



---

### Zero-extension / Sign-extension (확장)

작은 값을 큰 레지스터에 옮길 때, 빈자리를 어떻게 채울지가 문제다.

*   **Zero-extension (`movz`)**
    *   남는 상위 바이트를 **0으로 채움**
    *   명령어: `movzbw`, `movzbl`, `movzwl`, `movzbq`, `movzwq`
    *   예시: `movzbq %al, %rax` (상위 56비트는 0)

*   **Sign-extension (`movs`)**
    *   남는 상위 바이트를 **부호비트 값으로 채움** (0-양수 / 1-음수)
    *   명령어: `movsbw`, `movsbl`, `movswl`, `movsbq`, `movswq`
    *   예시: `movsbq %al, %rax` (상위 56비트는 부호비트로 채움)



---

### 3.4.4 스택 데이터의 저장과 추출 (Pushing / Popping Stack Data)

#### 1. 개념
*   **스택(Stack)**: LIFO(후입선출) 자료구조
*   X86-64에서는 메모리의 배열의 일부를 스택으로 사용
*   `%rsp` 레지스터가 스택의 **꼭대기(top)**를 가리킴 (스택은 낮은 주소 방향으로 자람)

#### 2. 명령어 동작
*   **`pushq S`**
    *   `%rsp` 값을 8 감소시킴 (`subq $8, %rsp`)
    *   새로 가리키는 메모리 위치에 값 저장 (`movq %rax, (%rsp)`)

*   **`popq D`**
    *   `%rsp`가 가리키는 메모리 값 읽기 (`movq (%rsp), %rdx`)
    *   `%rsp` 값을 8 증가시킴 (`addq $8, %rsp`)

#### 3. 정리
*   **pushq**: 스택 포인터 ↓ 후 값 저장
*   **popq**: 값 읽기 후 스택 포인터 ↑
*   스택은 **함수 호출/리턴, 지역 변수 저장** 등에서 핵심적 역할
